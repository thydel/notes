#!/usr/bin/make -f

MAKEFLAGS += -Rr
MAKEFLAGS += --warn-undefined-variables
SHELL := $(shell which bash)
.SHELLFLAGS := -euo pipefail -c

.ONESHELL:
.DELETE_ON_ERROR:
.PHONY: phony

.RECIPEPREFIX :=
.RECIPEPREFIX +=

.DEFAULT_GOAL := main

-: min := 4.1
-: msg := make $(MAKE_VERSION) < $(min)
-: - := $(and $(or $(filter $(min),$(firstword $(sort $(MAKE_VERSION) $(min)))),$(error $(msg))),)

-: ~ != git rev-parse --is-inside-work-tree > /dev/null 2>&1 && date
-: - := $(and $(or $~,$(error not in a git dir)),)

. != git rev-parse --show-toplevel

$(if $(filter guile, $(.FEATURES)),\
  $(guile (chdir (gmk-expand "$."))),\
  $(if $(filter $(PWD),$.),,$(error $(MAKEFILE_LIST) -C $. $(MAKEFLAGS) $(MAKECMDGOALS))))

ifdef NEVER
any.l := lib func
any.d := relative dir path
any.o := relative out dir path
any.f := relative file path
any.p := list of path
any.s := list of name, var, basename, ...
any.m := a pattern
endif

€ = $(subst €,$$,$1)

eq.l = $(and $(findstring $(strip $1),$(strip $2)),$(findstring $(strip $2),$(strip $1)))
cdr.l = $(filter-out $(firstword $1), $1)
map.l = $(eval λ = $(subst €,$$,$1))$(foreach _,$2,$(call λ,$_))
andb.l = $(if $(strip $1),$(if $(strip $2),T),)

define varbysuff.l
$(strip
  $(foreach v, $(.VARIABLES),
    $(foreach s, $1,
      $(if
        $(call andb.l,
          $(call eq.l, $(origin $v), file),
          $(call eq.l, $(suffix $v), .$(strip $s))),
        $v))))
endef

/ :=
$(call /, Will help to make comments)

define import.l
$(strip
                              $(call /, import var €2 from target €1 in var €3)
                              $(call /, or import all €2 vars in €1 (or €(€1)) as target.var)
  $(eval - := $(strip $1))    $(call /, The name of a target)
  $(eval ~ := $(or $($-),$-)) $(call /, Or a var containing the name of a target)
  $(eval 3 ?=)                $(call /, Arg 3 default to empty (avoid undef))
  $(if $3,
    $(eval $~: - := $$(eval $3 := $$($(strip $2)))),
    $(foreach _, $2, $(eval $~: - := $$(eval $-.$_ := $$($_))))
  )
)
endef

top.d := top
new.d := $(top.d)/new
ren.d := $(top.d)/type

|F = $(notdir $|)
$(top.d)/.gitignore: | $(ren.d); echo -e '/*\n!$(|F)' > $@

define ~head
---
title:
date: $(day)
id: "§$(id)"
tags:
type:
endef
define ~tail
[Local Variables:]::
[indent-tabs-mode: nil]::
[End:]::
endef
~ := new
$~: date != date -u +'%F %FT%TZ'
$~: day  := $(firstword $(date))
$~: id   := $(lastword $(date))
$~: head := $(~head)
$~: tail := $(~tail)
$~: file := $(new.d)/$(subst :,_,$(id)).md
$~: show := echo : $(date)
$~: cmd  := echo -e '$(head)\n---\n\n$(tail)'
$~: rcp   = cd $.; $(show); $(cmd) > $(file)
$~: phony $(top.d)/.gitignore | $(new.d); @$(rcp)

ifdef ONCE
~ := fixtail
$~: list := grep -L indent-tabs-mode id/*.md
$~: tail := $(~tail)
$~: add  := (echo; echo "$(tail)") | cat >> {}
$~: $~   := $(list) | xargs -i echo '$(add)'
$~: phony; @$($@)

# € is quoted $
# greek κ is quoted '
# « and » are quoted "
# greek ν is quoted NL
~ := fixhead
$~: list := grep -L ^id: id/*.md | tee $(tmp.t)/$~ | xargs basename -s .md
$~: list += | tr _ : | sed -e s/^/§/ | paste $(tmp.t)/$~ -
$~: ed   := /^date:/aνid: «%s»ν.νwq
$~: awk  := { printf "echo -e κ$(ed)κ | ed %s\n", €2, €1 }
$~: sed  := sed -e "s/κ/'/g" -e 's/[«»]/"/g' -e 's/ν/\\n/g'
$~: $~   := $(list) | awk '$(call €,$(awk))' | $(sed)
$~: phony; @$($@)
endif

json2any.o := $(top.d)/tmp/json2any

md.p != cd $.; test -d $(top.d) && find $(top.d) -type f -name '*.md' | grep -v $(json2any.o)

json.s :=
~ =
~ += $(eval name := $(basename $(notdir $1)).json)
~ += $(eval $(name) := $1)
~ += $(eval json.s += $(name))
$(call map.l, €(call ~, €1), $(md.p))

.SECONDEXPANSION:

lib.d := lib
md2json.o := $(top.d)/tmp/md2json

#VPATH = $.
vpath %.md $.
vpath %.json $.

md2json.p := $(json.s:%=$(md2json.o)/%)

# For all variables ending in .[do] used as ORDER-ONLY-PREREQUISITES
$(call map.l, €(€1), $(call varbysuff.l, d o)):; mkdir -p $@

~ := $(md2json.o)/%.json
$~: md = $(subst $./,,$<)
$~: json = $@
$~: file = $(notdir $<)
$~: base = $(basename $(file))
$~: jq = . + { file: "$(md)" }
$~: cmd = pandoc $(md) --template $(lib.d)/meta.json | jq '$(jq)' > $(json)
$~: $$($$(@F)) $./.stone | $(md2json.o); @cd $.; echo : $(json); $(cmd)
jsons: $(md2json.p)

json.f := $(json2any.o)/all.json
$(json.f): sort := jq -s 'sort_by(.date)|reverse|.[]'
$(json.f): $(md2json.p) | $(json2any.o); @cd $.; echo : $(@); cat $^ | $(sort) > $@
json: phony $(json.f) | $(md2json.o)

~ := ren
$~: jq.select := map(select(.type != "" and .title != ""))
$~: jq.mkdir := "cd $./$(ren.d)",
$~: jq.mkdir += (map(.type) | unique | ("mkdir -p " + join(" ")))
$~: jq.mv := "cd $.",
$~: jq.mv += (.[] | "$(ren.d)/\(.type)/\(.date)-\(.title | section_id).md" as €futur
$~: jq.mv += | if .file == €futur then empty else
$~: jq.mv += "mv \(.file) \(€futur)" end)
$~: jq :=
$~: jq += def section_id: split(" ") | map(ascii_downcase) | map(gsub("[^[:alnum:]]"; "")) | join("-");
$~: jq += $(jq.select) | ($(jq.mkdir), ($(jq.mv)))
$~: $~ := < $(json.f) jq -sr '$(call €,$(jq))'
$~: $(json.f) | $(ren.d); @cd $.; $($@)

χ := \\"#"
quote.l = $(subst «,$(χ),$(subst »,$(χ),$1))

σ :=  # Non breaking space

link2md.jq.reference := [\(.id)]: /\(.file) «\(.id) \(.title)»
link2md.jq.bare      := [§$(σ)\(.title)][\(.id)]
link2md.jq.readme    := - \(.date) $(link2md.jq.bare)

$(call import.l, ren, jq.select)
define link2md.jq
$(ren.jq.select)
| map($(call quote.l,"$(link2md.jq.reference)"))
+ [""] + map("$(strip $1)") | .[]
endef

link2md.sh = jq -sr $$'$(strip $(call link2md.jq, $1))'

~ := $(json2any.o)/link.md
$~: $~ := $(call link2md.sh, $(link2md.jq.bare))
$~: $(json.f); < $< $($@) > $@
link.f := $~
link: phony $~ | $(json2any.o)

~ := $(json2any.o)/readme.md
$~: $~ := $(call link2md.sh, $(link2md.jq.readme))
$~: $(json.f); < $< $($@) > $@
readme.f := $~
readme: phony $~ | $(json2any.o)

~ := README.md
$~: $~ := echo -e '\# notes\n\nTry to use zettelkasten via minimal MD and pandoc\n';
$~: $~ += cat
$~: $(readme.f); ($($@)) < $< > $@
README: phony $~

~ := fixlink
$~: id := ^\[§[[:alnum:]:-]*\]:
$~: list := grep -l '$(id)' $(md.p)
$~: awk  = BEGIN { while((getline < "$<") > 0) { t[€1] = €0 } }
$~: awk += /$(id)/ { €0 = t[€1]; print; next }
$~: awk += 1
$~: inplace := -i inplace -v inplace::suffix=.bak # wait for awk 5
$~: inplace := -i inplace -v INPLACE_SUFFIX=.bak
$~: $~ = $(list) | xargs -i echo awk $(inplace) \''$(call €,$(awk))'\' {}
$~: $(link.f) phony; @cd $.; $($@)

$(call import.l, fixlink, id)
~ := showlink
$~: id := $(fixlink.id)
$~: $~ := grep '$(id)' $(md.p)
$~: $(link.f) phony; @cd $.; $($@)

main: phony README;

try: phony; pandoc $(lastword $(md.p)) -t markdown_github --filter lib/try.sh

.stone:; cd $.; touch $@
stone: phony; cd $.; touch .$@

# Local Variables:
# indent-tabs-mode: nil
# End:
