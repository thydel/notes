#!/usr/bin/make -f

MAKEFLAGS += -Rr
MAKEFLAGS += --warn-undefined-variables
SHELL := $(shell which bash)
.SHELLFLAGS := -euo pipefail -c

.ONESHELL:
.DELETE_ON_ERROR:
.PHONY: phony

.RECIPEPREFIX :=
.RECIPEPREFIX +=

.DEFAULT_GOAL := main

-: min := 4.1
-: msg := make $(MAKE_VERSION) < $(min)
-: - := $(and $(or $(filter $(min),$(firstword $(sort $(MAKE_VERSION) $(min)))),$(error $(msg))),)

-: ~ != git rev-parse --is-inside-work-tree > /dev/null 2>&1 && date
-: - := $(and $(or $~,$(error not in a git dir)),)

. != git rev-parse --show-toplevel

$(if $(filter guile, $(.FEATURES)),\
  $(guile (chdir (gmk-expand "$."))),\
  $(if $(filter $(PWD),$.),,$(error $(MAKEFILE_LIST) -C $. $(MAKEFLAGS) $(MAKECMDGOALS))))

ifdef NEVER
any.l := lib func
any.d := relative dir path
any.o := relative out dir path
any.f := relative file path
any.p := list of path
any.s := list of name, var, basename, ...
any.m := a pattern
endif

€ = $(subst €,$$,$1)

eq.l = $(and $(findstring $(strip $1),$(strip $2)),$(findstring $(strip $2),$(strip $1)))
cdr.l = $(filter-out $(firstword $1), $1)
map.l = $(eval λ = $(subst €,$$,$1))$(foreach _,$2,$(call λ,$_))
andb.l = $(if $(strip $1),$(if $(strip $2),T),)

define varbysuff.l
$(strip
  $(foreach v, $(.VARIABLES),
    $(foreach s, $1,
      $(if
        $(call andb.l,
          $(call eq.l, $(origin $v), file),
          $(call eq.l, $(suffix $v), .$(strip $s))),
        $v))))
endef

define import.l
$(strip
  $(eval ~ := $(strip $1))
  $(eval 3 ?=)
  $(if $3,
    $(eval $~: - := $$(eval $3 := $$($(strip $2)))),
    $(foreach _, $2, $(eval $~: - := $$(eval $~.$_ := $$($_))))))
endef

top.d := top
new.d := $(top.d)/new

|F = $(notdir $|)
$(top.d)/.gitignore: | $(new.d); echo $(|F) > $@

define ~head
---
title:
date: $(day)
id: "§$(id)"
tags:
type:
endef
define ~tail
[Local Variables:]::
[indent-tabs-mode: nil]::
[End:]::
endef
~ := new
$~: date != date -u +'%F %FT%TZ'
$~: day  := $(firstword $(date))
$~: id   := $(lastword $(date))
$~: head := $(~head)
$~: tail := $(~tail)
$~: file := $(new.d)/$(subst :,_,$(id)).md
$~: show := echo : $(date)
$~: cmd  := echo -e '$(head)\n---\n\n$(tail)'
$~: rcp   = cd $.; $(show); $(cmd) > $(file)
$~: phony $(top.d)/.gitignore | $(new.d); @$(rcp)

json2any.o := $(top.d)/tmp/json2any

md.p != cd $.; test -d $(top.d) && find $(top.d) -type f -name '*.md' | grep -v $(json2any.o)

json.s :=
~ =
~ += $(eval name := $(basename $(notdir $1)).json)
~ += $(eval $(name) := $1)
~ += $(eval json.s += $(name))
$(call map.l, €(call ~, €1), $(md.p))

.SECONDEXPANSION:

lib.d := lib
md2json.o := $(top.d)/tmp/md2json

#VPATH = $.
vpath %.md $.
vpath %.json $.

md2json.p := $(json.s:%=$(md2json.o)/%)

ren.d := $(top.d)/type

# For all variables ending in .[do] used as ORDER-ONLY-PREREQUISITES
$(call map.l, €(€1), $(call varbysuff.l, d o)):; mkdir -p $@

~ := $(md2json.o)/%.json
$~: md = $(subst $./,,$<)
$~: json = $@
$~: file = $(notdir $<)
$~: base = $(basename $(file))
$~: jq = . + { file: "$(md)" }
$~: cmd = pandoc $(md) --template $(lib.d)/meta.json | jq '$(jq)' > $(json)
$~: $$($$(@F)) $./.stone | $(md2json.o); @cd $.; echo : $(json); $(cmd)
jsons: $(md2json.p)

json.f := $(json2any.o)/all.json
$(json.f): sort := jq -s 'sort_by(.date)|reverse|.[]'
$(json.f): $(md2json.p) | $(json2any.o); @cd $.; echo : $(@); cat $^ | $(sort) > $@
json: phony $(json.f) | $(md2json.o)

~ := ren
$~: jq.select := map(select(.type != ""))
#$~: jq.mkdir := "mkdir -p $./$(ren.d)",
$~: jq.mkdir :=
$~: jq.mkdir += "cd $./$(ren.d)",
$~: jq.mkdir += (map(.type) | unique | ("mkdir -p " + join(" ")))
$~: jq.mv := "cd $.",
$~: jq.mv += (.[] | "$(ren.d)/\(.type)/\(.date)-\(.title | section_id).md" as €futur
$~: jq.mv += | if .file == €futur then empty else
$~: jq.mv += "mv \(.file) \(€futur)" end)
$~: jq :=
$~: jq += def section_id: split(" ") | map(ascii_downcase) | map(gsub("[^[:alnum:]]"; "")) | join("-");
$~: jq += $(jq.select) | ($(jq.mkdir), ($(jq.mv)))
$~: $~ := < $(json.f) jq -sr '$(call €,$(jq))'
$~: $(json.f) | $(ren.d); @cd $.; $($@)

χ := \\"#"
quote.l = $(subst «,$(χ),$(subst »,$(χ),$1))

σ :=  # Non breaking space

~ := $(json2any.o)/link.md
$~: jq := map($(call quote.l,"[\(.id)]: /\(.file) «\(.id) \(.title)»"))
$~: jq += + [""] +
$~: jq += map("[§$(σ)\(.title)][\(.id)]")
$~: jq += | .[]
$~: $~ := jq -sr $$'$(jq)' $(json.f)
$~: $(json.f); cd $.; $($@) > $@
link.f := $~
link: phony $~ | $(json2any.o)

~ := fixlink
$~: id := ^\[§[[:alnum:]:-]*\]:
$~: list := grep -l '$(id)' $(md.p)
$~: awk  = BEGIN { while((getline < "$<") > 0) { t[€1] = €0 } }
$~: awk += /$(id)/ { €0 = t[€1]; print; next }
$~: awk += 1
$~: inplace := -i inplace -v inplace::suffix=.bak # wait for awk 5
$~: inplace := -i inplace -v INPLACE_SUFFIX=.bak
$~: $~ = $(list) | xargs -i echo awk $(inplace) \''$(call €,$(awk))'\' {}
$~: $(link.f) phony; @cd $.; $($@)

$(call import.l, fixlink, id)
~ := showlink
$~: id := $(fixlink.id)
$~: $~ := grep '$(id)' $(md.p)
$~: $(link.f) phony; @cd $.; $($@)

main: phony;

.stone:; cd $.; touch $@
stone: phony; cd $.; touch .$@

# Local Variables:
# indent-tabs-mode: nil
# End:
