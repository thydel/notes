#!/usr/bin/make -f

MAKEFLAGS += -Rr
MAKEFLAGS += --warn-undefined-variables
SHELL := $(shell which bash)
.SHELLFLAGS := -euo pipefail -c

.ONESHELL:
.DELETE_ON_ERROR:
.PHONY: phony

.RECIPEPREFIX :=
.RECIPEPREFIX +=

.DEFAULT_GOAL := main

-: min := 4.1
-: msg := make $(MAKE_VERSION) < $(min)
-: - := $(and $(or $(filter $(min),$(firstword $(sort $(MAKE_VERSION) $(min)))),$(error $(msg))),)

-: ~ != git rev-parse --is-inside-work-tree > /dev/null 2>&1 && date
-: - := $(and $(or $~,$(error not in a git dir)),)

. != git rev-parse --show-toplevel
#VPATH := $.

any.l := lib func
any.d := relative dir path
any.t := relative tmp dir path
any.f := relative file path
any.p := list of path
any.s := list of name, var, basename, ...
any.m := a pattern

€ = $(subst €,$$,$1)

eq.l = $(and $(findstring $(strip $1),$(strip $2)),$(findstring $(strip $2),$(strip $1)))
cdr.l = $(filter-out $(firstword $1), $1)
map.l = $(eval λ = $(subst €,$$,$1))$(foreach _,$2,$(call λ,$_))

define varbysuff.l
$(strip
  $(foreach _, $(.VARIABLES),
    $(if
      $(and
        $(call eq.l, $(origin $_), file),
        $(call eq.l, $(suffix $_), .$(strip $1))),
      $_)))
endef

define import.l
$(strip
  $(eval ~ := $(strip $1))
  $(eval 3 ?=)
  $(if $3,
    $(eval $~: - := $$(eval $3 := $$($(strip $2)))),
    $(foreach _, $2, $(eval $~: - := $$(eval $~.$_ := $$($_))))))
endef

top.d := new
id.d := $(top.d)/id

tmpdir.s := $(call map.l, €(€1), $(call varbysuff.l, t))
tmp: phony $(patsubst %, %/.stone, $(tmpdir.s))

define ~head
---
title:
date: $(day)
id: "§$(id)"
tags:
type:
endef
define ~tail
[Local Variables:]::
[indent-tabs-mode: nil]::
[End:]::
endef
~ := new
$~: date != date -u +'%F %FT%TZ'
$~: day  := $(firstword $(date))
$~: id   := $(lastword $(date))
$~: head := $(~head)
$~: tail := $(~tail)
$~: file := $(id.d)/$(subst :,_,$(id)).md
$~: phony $(id.d)/.stone; @ cd $.; echo -e '$(head)\n---\n\n$(tail)' > $(file)

tmp.t := $(top.d)/spl/tmp

md.p != cd $.; test -d $(top.d) && find $(top.d) -type f -name '*.md' | grep -v $(tmp.t)

json.s :=
~ =
~ += $(eval name := $(basename $(notdir $1)).json)
~ += $(eval $(name) := $1)
~ += $(eval json.s += $(name))
$(call map.l, €(call ~, €1), $(md.p))

.SECONDEXPANSION:

lib.d := lib
json.d := $(top.d)/spl/json

#vpath %.json $(json.d)

json.p := $(json.s:%=$(json.d)/%)

~ := $(json.d)/%.json
$~: md = $(subst $./,,$<)
$~: json = $@
$~: file = $(notdir $<)
$~: base = $(basename $(file))
$~: jq = . + { file: "$(md)" }
$~: cmd = pandoc $(md) --template $(lib.d)/meta.json | jq '$(jq)' > $(json)
$~: $$($$(@F)) $(json.d)/.stone $./.stone; @cd $.; echo : $(json); $(cmd)
jsons: $(json.p)

json.f := $(tmp.t)/all.json
$(json.f): sort := jq -s 'sort_by(.date)|reverse|.[]'
$(json.f): $(tmp.t)/.stone $(json.p); @cd $.; echo : $(@); cat $(call cdr.l, $^) | $(sort) > $@
json: phony $(json.f)

~ := ren
$~: jq :=
$~: jq += def section_id: split(" ") | map(ascii_downcase) | map(gsub("[^[:alnum:]]"; "")) | join("-");
$~: jq += "$(top.d)/\(.type)/\(.date)-\(.title | section_id).md" as €futur
$~: jq += | if .file == €futur then empty else
$~: jq += "cd $.; mkdir -p $(top.d)/\(.type); mv \(.file) \(€futur); touch $(json.d)/.stone" end
$~: $~ := < $(json.f) jq -r '$(call €,$(jq))'
$~: $(json.f); @cd $.; $($@)

χ := \\"#"
quote.l = $(subst «,$(χ),$(subst »,$(χ),$1))

σ :=  # Non breaking space

~ := $(tmp.t)/link.md
$~: jq := map($(call quote.l,"[\(.id)]: \(.file) «\(.id) \(.title)»"))
$~: jq += + [""] +
$~: jq += map("[§$(σ)\(.title)][\(.id)]")
$~: jq += | .[]
$~: $~ := jq -sr $$'$(jq)' $(json.f)
$~: $(json.f); $($@) > $@
link.f := $~
link: $~ $(tmp.t)/.stone phony

~ := fixlink
$~: id := ^\[§[[:alnum:]:-]*\]:
$~: list := grep -l '$(id)' $(md.p)
$~: awk  = BEGIN { while((getline < "$<") > 0) { t[€1] = €0 } }
$~: awk += /$(id)/ { €0 = t[€1]; print; next }
$~: awk += 1
$~: inplace := -i inplace -v inplace::suffix=.bak # wait for awk 5
$~: inplace := -i inplace -v INPLACE_SUFFIX=.bak
$~: $~ = $(list) | xargs -i echo awk $(inplace) \''$(call €,$(awk))'\' {}
$~: $(link.f) phony; @cd $.; $($@)

$(call import.l, fixlink, id)
~ := showlink
$~: id := $(fixlink.id)
$~: $~ := grep '$(id)' $(md.p)
$~: $(link.f) phony; @cd $.; $($@)

main: phony;

%/.stone:; cd $.; mkdir -p $(@D); touch $@
.PRECIOUS: %/.stone

.stone:; cd $.; touch $@
stone: phony; cd $.; touch .$@

# Local Variables:
# indent-tabs-mode: nil
# End:
